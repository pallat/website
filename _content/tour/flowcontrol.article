Flow control statements: for, if, else, switch and defer
เรียนรู้วิธีการควบคุมโฟลวในโค้ดด้วยการใส่เงื่อนไข วนลูป ตัวเลือก และ defer

The Go Authors
https://golang.org

* For

Go มีวิธีการวบลูปแบบเดียวด้วยการใช้ `for`

พื้นฐานของ `for` จะประกอบไปด้วยสามส่วนแยกกันด้วยเครื่องหมายเซมิโคลอน:

- ส่วนกำหนดค่าเริ่มต้น: ถูกทำก่อนเริ่มวนรอบแรก
- ส่วนของเงื่อนไข: ถูกคำนวณก่อนจะเริ่มทำงานในแต่ละรอบ
- ส่วนปิดท้าย: ถูกทำหลังจากจบการทำงานในแต่ละรอบ

ส่วนกำหนดค่าเริ่มต้นนั้นมักจะเป็นการประการตัวแปรแบบสั้นๆ และเมื่อประกาศแล้วมันจะมีตัวตนอยู่เพียง
แค่ในขอบเขตของ `for` เท่านั้น

ลูปจะหยุดทันทีเมื่อเงื่อนไขถูกตัดสินว่าเป็น `false`

*สังเกตว่า:* จุดที่แตกต่างจากภาษาอื่นๆ อย่าง C, Java หรือ JavaScript ก็คือมันไม่ต้องมีวงเล็บครอบ
องค์ประกอบทั้งสามส่วนของ `for` และอีกอย่างคือวงเล็บปีกา `{`}` จะต้องใส่ไว้เสมอ

.play flowcontrol/for.go

* For continued

ส่วนกำหนดค่าเริ่มต้น และส่วนปิดท้าย เป็นเพียงตัวเลือกให้มีหรือไม่มีก็ได้

.play flowcontrol/for-continued.go

* For is Go's "while"

ณ จุดนี้ คุณสามารถลบเซมิโคลอนออกไปได้เลย: `while` ในภาษา C ก็คือ `for` ในภาษา Go นั่นเอง

.play flowcontrol/for-is-gos-while.go

* Forever

ถ้าคุณเอาเงื่อนไขออกไปอีก มันจะวนลูปไปตลอดกาล นั่นไง อินฟินิตี้ลูป ก็เขียนกันง่ายๆ แบบนี้เอง

.play flowcontrol/forever.go

* If

`if` ใน Go ก็คล้ายๆ กับ `for` ตรงจุดที่ไม่ต้องใช้วงเล็บ `(`)` ครอบเงื่อนไข แต่จำเป็นต้องใส่วงเล็บปีกกา `{`}` เสมอ

.play flowcontrol/if.go

* If with a short statement

`if` มีจุดที่คล้ายกับ `for` ตรงที่สามารถมีชุดคำสั่งสั้นๆ ให้ทำก่อนการตรวจสอบเงื่อนไขได้

ตัวแปรที่ถูกประกาศในชุดคำสั่งนี้ จะมีขอบเขตไปจนจบ `if` เท่านั้น

(ลองเอา `v` ไปใส่ตรงส่วน `return` ในช่วงท้ายดูสิ)

.play flowcontrol/if-with-a-short-statement.go

* If and else

ตัวแปรที่ถูกประกาศใน `if` แบบ short statement ยังสามารถนำไปใช้ในบล็อคของ `else` ทั้งหมดได้ด้วย

(การเรียกใช้ `pow` ทั้งสองครั้งจะคืนผลลัพธ์ออกมาก่อนจะเรียก `fmt.Println` ตรงจุดที่ `main` เริ่มทำงาน)

.play flowcontrol/if-and-else.go

* Exercise: Loops and Functions

มีหนึ่งวิธีที่จะเล่นกับฟังก์ชั่นและลูป เรามาสร้างฟังก์ชั่นหาค่าสแควร์รูทกัน วิธีคือรับตัวเลขเข้ามาค่าหนึ่งชื่อ x เราต้องคืนค่า z ออกไป โดยที่ z² จะต้องมีค่าใกล้เคียงกับ x ให้มากที่สุด

ปกติแล้วคอมพิวเตอร์จะคำนวณค่าสแควร์รูทด้วยวิธีการวนลูป
โดยเริ่มต้นจากการเดาค่า z มาสักค่าหนึ่ง และค่อยๆ ปรับค่า z ให้ z² เข้าใกล้ค่า x
การทำแบบนี้เพื่อใด้เดาได้แม่นยำขึ้น:

	z -= (z*z - x) / (2*z)

การปรับค่านี้ซ้ำๆ จะทำให้การเดาค่าทำได้ได้แม่นยำขึ้นไปเรื่อยๆ
จนกว่าจะไปเจอคำตอบที่ใกล้เคียงกับค่าสแควร์รูทที่ควรจะเป็น

ทำฟังก์ชั่น `func`Sqrt` ที่เตรียมไว้ให้นี้
โดยให้กำหนดการเดาค่า z เริ่มต้นที่เลข 1  ไม่ว่าอินพุตจะเป็นค่าอะไร
และเริ่มคำนวณซ้ำ 10 รอบ พร้อมกับพิมพ์ค่า z ออกมาทุกครั้ง
เพิ่อดูว่าแต่ละค่า (1, 2, 3, ...) นั้นได้คำตอบเร็วแค่ไหน
และจะปรับปรุงให้เดาได้เร็วขึ้นได้อย่างไร

ตัวช่วย: การสร้างตัวแปรและกำหนดค่าเริ่มต้นแบบมีทศนิยม
ให้กำหนดค่าแบบมีจุดทศนิยมลงไปตรงๆ หรือใช้การแปลงค่ามาช่วย:

	z := 1.0
	z := float64(1)

ขั้นตอนต่อไป ให้เปลี่ยนเงื่อนไขของการวนลูป ให้หยุดเมื่อได้ค่าเดิมซ้ำๆ (หรือเปลี่ยนไปน้อยมากๆ)
สังเกตดูว่ามันทำมากกว่า หรือน้อยกว่า 10 รอบ
แล้วลองเปลี่ยนการเดาค่าเริ่มต้นของ z ไปเป็นอย่างอื่นเช่น ใช้ค่า x หรือ x/2
ผลลัพธ์ที่ได้จากฟังก์ชั่นของคุณ มันใกล้เคียงกับของ [[https://golang.org/pkg/math/#Sqrt][math.Sqrt]] ในไลบรารี่มาตรฐานแค่ไหน?

(*หมายเหตุ:* ถ้าคุณมีความสนใจตัวอัลกอรีธึม z² − x ที่อยู่ด้านบน
ว่า z² จะได้ค่าที่ใกล้เคียงจากค่า (x) ที่มันต้องการแค่ไหน และการหารด้วย 2z เป็นอนุพันธ์ของ z²
เพื่อปรับค่า z ให้ค่า z² เปลี่ยนได้เร็วขึ้นได้อย่างไร
วิธีนี้มีชื่อเรียกว่า [[https://en.wikipedia.org/wiki/Newton%27s_method][Newton's method]]
ในหลายๆ ฟังก์ชั่น มันทำงานได้ดีทีเดียว แต่มันดีเป็นพิเศษเมื่อใช้กับสแควร์รูท)

.play flowcontrol/exercise-loops-and-functions.go

* Switch

`switch` เป็นวิธีย่อขั้นตอนการทำ `if`-`else` ให้สั้นลง
มันจะรันเคสแรกที่มีค่าตรงตามเงื่อนไขที่กำหนด

switch ในภาษา Go จะเหมือนในภาษาอื่นอย่าง C, C++, Java, JavaScript, และ PHP
เว้นเสียแต่ว่า ใน Go จะรันเฉพาะเคสที่ถูกเลือกเท่านั้น ไม่ทำเคสถัดไปทั้งหมด
ด้วยเหตุนี้เอง ภาษาอื่นๆ จึงต้องการ `break` ปิดท้ายในแต่ละเคส ซึ่งใน Go จะทำให้โดยอัตโนมัติ
และอีกข้อแต่ต่างที่สำคัญเลยก็คือ ในแต่ละเคสของ switch ในภาษา Go นั้น
ไม่จำเป็นต้องเป็นค่าคงที่ และค่าที่เกี่ยวข้องก็ไม่จำเป็นต้องเป็น integer

.play flowcontrol/switch.go

* Switch evaluation order

เคสใน switch จะคิดตามลำดับจากบนลงล่าง และหยุดทันทีเมื่อเจอเคสที่ใช่

(ตัวอย่างเช่น,

	switch i {
	case 0:
	case f():
	}

ถ้า `i==0` ฟังก์ชั่น `f` จะไม่ถูกเรียก)

#appengine: *หมายเหตุ:* เวลาใน Go playground จะเริ่มต้นที่เวลา
#appengine: 2009-11-10 23:00:00 UTC เสมอ ความสำคัญของค่านี้ยกให้เป็นการบ้านของผู้อ่าน

.play flowcontrol/switch-evaluation-order.go

* Switch with no condition

switch แบบไม่มีเงื่อนไข ก็เหมือนกับ `switch`true` นั่นเอง

รูปแบบนี้ดูง่ายกว่าการเขียน if-then-else ต่อกันหลายๆชั้น

.play flowcontrol/switch-with-no-condition.go

* Defer

คำสั่ง defer จะหน่วงการเรียกฟังก์ชั่นนี้ไปจนกว่าฟังก์ชั่นที่ครอบมันไว้จะทำงานจนจบ

อากิวเมนต์ที่ถูก defer ไว้นี้จะถูกประมวลผลทันที แต่จะยังไม่เรียกใช้งานจนกว่าฟังก์ชั่นที่ครอบมันอยู่จะรีเทิร์น

.play flowcontrol/defer.go

* Stacking defers

ฟังก์ชั่นที่ถูก defer จะถูกดันไปเก็บไว้ในสแต็ก เมื่อฟังก์ชั่นรีเทิร์น
มันจะค่อยๆ ถูกเรียกตามลำดับ last-in-first-out จากล่างขึ้นบน

อ่านเพิ่มเติมเกี่ยวกับ defer ได้ที่
[[https://go.dev/blog/defer-panic-and-recover][blog post]].

.play flowcontrol/defer-multi.go

* Congratulations!

คุณสำเร็จบทเรียนนี้แล้ว!

คุณสามารถย้อนกลับไปดูรายการของ [[/list][modules]] เพื่อหาสิ่งที่ต้องการจะเรียนต่อ หรือไปที่ [[javascript:click('.next-page')][next lesson]] ด้วยกันเลย
