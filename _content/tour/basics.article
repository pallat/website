Packages, variables, และ functions.
เรียนรู้องค์ประกอบพื้นฐานของ Go

The Go Authors
https://golang.org

* Packages

โปรแกรม Go ถูกประกอบขึ้นมาจาก package

แพ็คเกจ `main` คือจุดเริ่มต้นการทำงานของโปรแกรม

โปรแกรมนี้เรียกใช้แพ็คเกจอื่นด้วยการอิมพอร์ตด้วย path `"fmt"` และ `"math/rand"` เข้ามา

ตามธรรมเนียม ชื่อแพ็คเกจจะเหมือนกับส่วนสุดท้ายของ path ตัวอย่างเช่น ในแพ็คเกจ `"math/rand"` จะมีไฟล์ต่างๆ ที่เริ่มต้นบรรทัดแรกว่า `package`rand`

#appengine: *หมายเหตุ:* สภาพแวดล้อมที่โปรแกรมเหล่านี้ทำงานนั้น ถูกกำหนดขึ้นอย่างตั้งใจ
#appengine: นั่นทำให้แต่ละครั้งที่โปรแกรมตัวอย่างนี้ทำงาน `rand.Intn` จะคืนเลขเดิมมาเสมอ
#appengine:
#appengine: (ถ้าอยากเห็นค่าอื่น ต้องมีตัวสร้าง seed; ดูได้ที่ [[https://golang.org/pkg/math/rand/#Seed][`rand.Seed`]]
#appengine: เวลาใน playground ก็เป็นค่าคงที่ ดังนั้นคุณต้องหาอะไรอย่างอื่นมาทำ seed แทนด้วย)

.play basics/packages.go

* Imports

โค้ดนี้จัดกลุ่มการ import เข้ามารวมไว้ในวงเล็บ หรือเรียกว่า "factored" import statement

หรือถ้าอยากจะเขียนให้ import หลายๆ ครั้งแบบนี้ก็ได้เช่นเดียวกัน:

	import "fmt"
	import "math"

แต่รูปแบบที่ดีก็คือใช้ factored import statement

.play basics/imports.go

* Exported names

ใน Go การตั้งชื่อมีความสำคัญ ถ้าชื่อขึ้นต้นด้วยตัวพิมพ์ใหญ่ ตัวอย่างเช่น `Pizza`
จะถือว่าเป็นชื่อสามารถถูกใช้จากภายนอกได้ เหมือนกับ `Pi` ที่ถูกส่งออกมาจากแพ็คเกจ `math`

ส่วน `pizza` และ `pi` ไม่ได้ขึ้นต้นด้วยตัวพิมพ์ใหญ่ ดังนั้นมันถึงไม่สามารถถูกใช้จากภายนอกได้

เมื่อเรา import แพ็คเกจเข้ามา เราจึงสามารถอ้างถึงได้เฉพาะชื่อที่ถูกส่งออกมาเท่านั้น
ชื่อใดก็ตามที่ไม่ได้ "ถูกส่งออกมา" เราจะไม่สามารถเข้าถึงจากภายนอกแพ็คเกจนั้นได้เลย

รันโค้ดนี้ แล้วสังเกตที่ error message

แก้ error นี้ด้วยการเปลี่ยนชื่อ `math.pi` เป็น `math.Pi` แล้วลองอีกที

.play basics/exported-names.go

* Functions

ฟังก์ชั่น สามารถรับอาร์กิวเมนต์ ศูนย์ตัว หรือมากกว่านั้นก็ได้

ในตัวอย่างนี้ add รับพารามิเตอร์ `int` เข้ามาสองตัว

สังเกตว่า type ของตัวแปรจะอยู่ _ด้านหลัง_ ชื่อตัวแปรนั้น

(หากอยากจะรู้ว่าทำไม type ถึงมีหน้าตาประมาณนี้ ให้ดูต่อที่ [[https://go.dev/blog/gos-declaration-syntax][article on Go's declaration syntax]].)

.play basics/functions.go

* Functions continued

เมื่อฟังก์ชั่นรับพารามิเตอร์สองตัวขึ้นไปติดกัน และมี type เดียวกัน คุณสามารถละการระบุ type ตัวอื่นๆ และไประบุที่ตัวสุดท้ายเลยก็ได้

เช่นตัวอย่างนี้ เราจะย่อจาก

	x int, y int

ไปเป็น

	x, y int

.play basics/functions-continued.go

* Multiple results

ฟังก์ชั่นสามารถคืนผลลัพธ์กี่ค่าก็ได้

ฟังก์ชั่น `swap` ที่เห็นนี้คืนสตริงสองตัว

.play basics/multiple-results.go

* Named return values

ใน Go ค่าที่จะคืนออกมา อาจจะถูกตั้งชื่อไว้ล่วงหน้าก็ได้ ถ้าทำแบบนั้น ตัวแปรเหล่านั้นจะถูกมองเสมือนว่าเป็นตัวแปรที่ถูกประกาศไว้ด้านบนในฟังก์ชั่นนั้น

ชื่อตัวแปรเหล่านี้ควรถูกใช้เป็นเสมือนเอกสารอ้างอิงที่สื่อให้รู้ว่าจะคืนค่าอะไรออกมา

คำสั่ง `return` ที่ไม่มีอากิวเม้นต์ คือการคืนค่าที่ตั้งชื่อรอไว้แต่แรก เราเรียกสิ่งนี้ว่าการคืนค่าแบบ "naked" return

คำสั่ง Naked return ควรถูกใช้ในฟังก์ชั่นที่ไม่ยาวมาก แบบที่เห็นในตัวอย่างนี้ เพราะมันจะทำให้อ่านยาก

.play basics/named-results.go

* Variables

คำสั่ง `var` สำหรับการประกาศชุดตัวแปร เช่นเดียวกับอากิวเม้นต์ในฟังก์ชั่น โดยประกาศ type ด้านหลังสุด

คำสั่ง `var` สามารถใช้ในฟังก์ชั่นหรือนอกฟังก์ชั่นในระดับแพ็คเกจก็ได้ ดังที่เราได้เห็นทั้งสองแบบในตัวอย่างนี้

.play basics/variables.go

* Variables with initializers

คำสั่ง var สามารถกำหนดค่าเริ่มต้นรวมเข้าไปได้ หนึ่งค่าต่อหนึ่งตัวแปร

ถ้ากำหนดค่าเริ่มต้นไปแล้ว สามารถละการระบุ type ได้ โดยตัวแปรนั้นจะได้ type มาจากค่าที่กำหนดให้

.play basics/variables-with-initializers.go

* Short variable declarations

ในฟังก์ชั่น สามารถย่อการประกาศตัวแปรโดยใช้ `:=` แทนการประกาศด้วย `var` ซึ่งจะได้รับ type ไปโดยปริยาย

นอกฟังก์ชั่น ทุกอย่างต้องเริ่มต้นด้วยคีย์เวิร์ด (`var`, `func`, หรือตัวอื่นๆ) ดังนั้นจึงไม่สามารถใช้ `:=` ได้

.play basics/short-variable-declarations.go

* Basic types

type พื้นฐานของ Go มีดังนี้

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // alias for uint8

	rune // alias for int32
	     // represents a Unicode code point

	float32 float64

	complex64 complex128

ตัวอย่างแสดงให้เห็นตัวแปรจากหลากหลาย type
และการประกาศตัวแปรก็อาจจะทำแบบ "factored" รวมไว้ในบล็อคแบบเดียวกับที่ทำใน import ก็ได้

type `int`, `uint`, และ `uintptr` จะมีขนาด 32 บิตบนระบบที่เป็น 32-bit และจะเป็น 64 บิต บนระบบที่เป็น 64-bit
หากคุณอยากได้ค่าที่เป็น integer คุณควรใช้ `int` เว้นแต่ว่าคุณมีเหตุผลเฉพาะที่ต้องใช้ค่า integer ที่ต้องระบุขนาด หรือ เป็นค่าสัมบูรณ์

.play basics/basic-types.go

* Zero values

ตัวแปรที่ถูกประกาศมาโดยไม่กำหนดค่าเริ่มต้น จะได้รับค่า _zero_value_ มาโดยปริยาย

zero value คือ:

- `0` ให้กับตัวแปรที่มี type เป็นตัวเลข
- `false` ให้กับตัวแปร type นิพจน์ และ
- `""` (the empty string) ให้กับสตริง

.play basics/zero.go

* Type conversions

การแสดงสัญลักษณ์ `T(v)` หมายถึงการแปลงค่า `v` ไปสู่ type `T`

การแปลงค่าตัวเลข:

	var i int = 42
	var f float64 = float64(i)
	var u uint = uint(f)

หรือทำให้ดูง่ายขึ้นแบบนี้:

	i := 42
	f := float64(i)
	u := uint(f)

Go ต่างจาก C ตรงที่การโยนค่าระหว่าง type ที่ต่างกันต้องมีการแปลงให้ชัดเจน
ทดลองลบการแปลง `float64` หรือ `uint` ออกจากในตัวอย่างแล้วดูว่าเกิดอะไรขึ้น

.play basics/type-conversions.go

* Type inference

เมื่อประกาศตัวแปรโดยไม่ระบุ type ให้ชัดเจน (ไม่ว่าจะเป็นแบบ `:=` หรือ `var`=`) type ของตัวแปรจะถูก อนุมาน จากค่าทางด้านขวา

เมื่อค่าทางด้านขวามีการประกาศ type มาแล้ว ตัวแปรใหม่ก็จะได้ type เดียวกันมาด้วย:

	var i int
	j := i // j is an int

แต่ถ้าค่าทางด้านขวาเป็นตัวเลขที่ไม่ระบุ type มาให้ ตัวแปรใหม่อาจจะได้ `int`, `float64`, หรือ `complex128` ก็ได้ ขึ้นอยู่กับรายละเอียดที่ให้ไว้กับค่านั้น

	i := 42           // int
	f := 3.142        // float64
	g := 0.867 + 0.5i // complex128

ทดลองแก้ค่าเริ่มต้นของ `v` ในโค้ดตัวอย่างและสังเกตดู type ของมัน

.play basics/type-inference.go

* Constants

ค่าคงที่ใช้การประกาศเหมือนตัวแปร เพียงแค่ใช้คีย์เวิร์ดเป็น `const` แทน

ค่าคงที่สามารถเป็นตัวอักขระ ชุดของสตริง นิพจน์ หรือตัวเลขก็ได้

ค่าคงที่ไม่สามารถประกาศโดยการใช้ `:=` ได้

.play basics/constants.go

* Numeric Constants

ค่าคงที่ของตัวเลขเป็น _ค่า_ ต้องการความแม่นยำอย่างมาก

ค่าคงที่ที่ไม่กำหนด type จะได้ type จากบริบทที่ได้รับมา

ลองเพิ่ม `needInt(Big)` เข้าไปดู

(`int` เก็บตัวเลขสูงสุดได้ 64-bit และน้อยกว่าในบางกรณี)

.play basics/numeric-constants.go

* Congratulations!

คุณทำสำเร็จบทเรียนนี้แล้ว

คุณสามารถย้อนกลับไปดูรายการของ [[/list][modules]] เพื่อหาสิ่งที่ต้องการจะเรียนต่อ หรือไปที่ [[javascript:click('.next-page')][next lesson]] ด้วยกันเลย
